{
  "query": " CALL {\n      UNWIND $nodesData as data\n      CALL apoc.create.node([data.class], data) YIELD node\n      SET node.processed = 0\n      WITH count(node) as nodeCount // needed to protect against empty parameter list\n      RETURN nodeCount // subqueries must return something\n    }\n    WITH nodeCount // only a single row at this point from the earlier aggregation\n    CALL {\n      UNWIND $edgesData AS data  \n      // you should be using labels or this will be really really slow!\n      MATCH (n {newtId: data.source}), (m { newtId: data.target})  \n      WITH n, m, data\n      CALL apoc.create.relationship(n,data.class,data,m) YIELD rel  \n      WITH rel\n      SET rel.processed = 0\n      // REMOVE rel.source, rel.target\n      WITH count(rel) as relCount\n      RETURN relCount\n    }\n    WITH relCount\n    CALL {\n      MATCH (n) WHERE EXISTS (n.parent) AND n.processed = 0\n      WITH n as childNode\n      MATCH (parentNode)\n      // get the parent node of a particular node\n      WHERE parentNode.newtId = childNode.parent\n      // create relationship of type PARENT_OF with weight 0\n      CALL apoc.create.relationship(childNode, \"belongs_to_\" + parentNode.class, {language:\"PD\"}, parentNode) \n      YIELD rel\n      WITH rel, parentNode, childNode\n      SET rel.processed = 0, rel.source = childNode.newtId, rel.target = parentNode.newtId\n      WITH rel, parentNode, childNode\n      SET childNode.parent = id(parentNode)\n      WITH count(rel) as parentRel\n      RETURN parentRel\n    }\n    RETURN parentRel\n      "
}